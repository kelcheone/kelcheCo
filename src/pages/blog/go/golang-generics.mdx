---
layout: "@layouts/ArticleLayout.astro"
title: Golang Generics (A Complete Guide)
description: In Go 1.18 genereics were introduced, this enables us to write generic functions and types. In this article we will learn about generics in Go.
date: 15 January 2023
image: https://images.unsplash.com/photo-1642367340318-96fdbc5d30f5?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=870&q=80
imageDescription: Golang Generics
imageSource: unsplash
imageUrl: https://unsplash.com/photos/fd9mIBluHkA
keywords:
  - golang generics
  - golang generics guide
  - golang generics tutorial
  - golang generics complete guide
tags:
  - featured
  - go
---

import Nugget from "@components/Nugget.astro";

## Table of Contents

- [Introduction](#introduction)
- [What are Generics?](#what-are-generics)
- [Interfaces](#interfaces)
- [Generic Interfaces](#generic-interfaces)
- [Type inference](#type-inference)
- [Generic Functions](#generic-functions)
- [Generic Types](#generic-types)
- [Generic Constraints](#generic-constraints)
- [Generic Methods](#generic-methods)
- [Generic Methods](#generic-methods)
- [Generic Variadic Functions](#generic-variadic-functions)
- [Generic Variadic Methods](#generic-variadic-methods)
- [Generic Variadic Types](#generic-variadic-types)
- [Generic Variadic Constraints](#generic-variadic-constraints)
- [Conclusion](#conclusion)

## Introduction

Golang genereics were introduced in Go 1.18, this enables us to write generic functions and types.

<Nugget>
  <strong>NOTE:</strong> This article assumes that you have go 1.18 or later
  installed on your machine. If you don't, you can download it from{" "}
  <a href="https://go.dev/dl/">here</a>.
</Nugget>

## What are Generics?

Generics are a way to write functions and types that can work with any type. This is similar to how we write functions and types that work with any type in JavaScript.
Generics allows types to be parameterized over types or values.

Before the launch of go 1.18, we had to write a lot of boilerplate code to write generic functions and types. For example, let's look at how we would write a generic function that takes a slice of any type and returns the first element of the slice.

```go title="example.go"
package main

import "fmt"

func FirstInt(s []int) int {
    return s[0]
}

func FirstString(s []string) string {
    return s[0]
}

func main() {
    fmt.Println(FirstInt([]int{1, 2, 3}))
    fmt.Println(FirstString([]string{"a", "b", "c"}))
}
```

In the above example, we defined two functions `FirstInt` and `FirstString` that take a slice of `int` and `string` respectively and return the first element of the slice. We then called the functions with two different types, `int` and `string`.

We could use Generic Interfaces with no constraints to achieve the same result.

```go title="example.go"
package main

import "fmt"

func First[T interface{}](s []T) T {
    return s[0]
}

func main() {
    fmt.Println(First([]int{1, 2, 3}))
    fmt.Println(First([]string{"a", "b", "c"}))
}
```

In the above example, we defined a generic function `First` that takes a slice of any type `T` and returns the first element of the slice. We then called the function with two different types, `int` and `string`.

## Interfaces

Before we dive into generics, let's first understand interfaces. Interfaces are a way to define a set of methods that a type must implement. For example, the `io.Writer` interface defines a set of methods that a type must implement to be a writer.

```go title="example.go"
package main

import (
    "fmt"
    "io"
)

type Writer interface {
    Write(p []byte) (n int, err error)
}

func main() {
    var w Writer
    w = os.Stdout
    fmt.Fprintf(w, "hello, writer\n")
}
```

In the above example, we defined a `Writer` interface that defines a `Write` method. We then defined a variable `w` of type `Writer` and assigned it to `os.Stdout`. This is possible because `os.Stdout` implements the `Writer` interface.

## Generic Interfaces

Let's now look at how we can write generic interfaces in Go. We will start by writing a generic interface that defines a `Write` method that takes a slice of any type and returns the number of bytes written and an error.

```go title="example.go"
package main

import (
    "fmt"
    "io"
    "os"
)

type Writer[T any] interface {
    io.Writer
    Write(p []T) (n int, err error)
}

func main() {
    var w Writer[int]
    w = os.Stdout
    fmt.Fprintf(w, "hello, writer\n")
}
```

Output:

```bash title="output"
hello, writer
```

In the above example, we defined a generic interface `Writer` that defines a `Write` method that takes a slice of any type `T` and returns the number of bytes written and an error. We then defined a variable `w` of type `Writer[int]` and assigned it to `os.Stdout`. This is possible because `os.Stdout` implements the `Writer` interface.

## Type inference

Let's now look at how we can use type inference in Go. We will start by writing a generic function that takes a slice of any type and returns the first element of the slice.

```go title="example.go"
package main

import "fmt"

func First[T any](s []T) T {
    return s[0]
}

func main() {
    fmt.Println(First([]int{1, 2, 3}))
    fmt.Println(First([]string{"a", "b", "c"}))
}
```

Output:

```bash title="output"
1
a
```

In this example, we defined a generic function `First` that takes a slice of any type `T` and returns the first element of the slice. We then called the function with two different types, `int` and `string`. The compiler is able to infer the type of the generic function from the type of the arguments passed to the function.

## Generic Functions

Let's now look at how we can write generic functions in Go. We will start by writing a generic function that takes a slice of any type and returns the first element of the slice.

```go title="example.go"
package main

import "fmt"


func First[T any](s []T) T {
    return s[0]
}

func main() {
    fmt.Println(First([]int{1, 2, 3}))
    fmt.Println(First([]string{"a", "b", "c"}))
}
```

Output:

```bash title="output"
1
a
```

In the above example, we defined a generic function `First` that takes a slice of any type `T` and returns the first element of the slice. We then called the function with two different types, `int` and `string`.

## Generic Types

Generic types are types that can work with any type. Let's look at an example of a generic type that implements the `Writer` interface.

```go title="example.go"
package main

import (
    "fmt"
    "io"
    "os"
)

type Writer[T any] struct {
    w io.Writer
}

func (w *Writer[T]) Write(p []byte) (n int, err error) {
    return w.w.Write(p)
}

func main() {
    w := Writer[int]{os.Stdout}
    w.Write([]byte("hello"))

}
```

Output:

```bash title="output"
hello
```

In the above example, we defined a generic type `Writer` that implements the `Writer` interface. We then defined a variable `w` of type `Writer[int]` and assigned it to `os.Stdout`. This is possible because `os.Stdout` implements the `Writer` interface.

## Generic Constraints

We can also add constraints to generic types and functions. Let's look at an example of a generic function that takes a slice of any type that implements the `io.Writer` interface and returns the first element of the slice.

```go title="example1.go"
package main

import (
    "io"
    "os"
)

func First[T io.Writer](s []T) T {
    return s[0]
}

func main(){
    w := First([]io.Writer{os.Stdout, os.Stderr})
    w.Write([]byte("hello"))
}
```

Output:

```bash title="output"
hello
```

```go title="example2.go"
package main

import (
    "fmt"
    "io"
)

func First[T io.Writer](s []T) T {
    return s[0]
}

func main() {
    fmt.Println(First([]int{1, 2, 3}))
    fmt.Println(First([]string{"a", "b", "c"}))
}
```

Output:

```bash title="output"
# constraints
./main.go:15:22: int does not implement io.Writer (missing Write method)
./main.go:16:22: string does not implement io.Writer (missing Write method)
```

In the above two code blocks we introduced genereic constraint to the generic function `First`. In the both examples, `First` takes `T` as a generic type that implements the `io.Writer` interface. In the first example, we passed a slice of `io.Writer` to the function and it worked as expected. In the second example, we passed a slice of `int` and `string` to the function and it failed to compile because `int` and `string` do not implement the `io.Writer` interface.

## Generic Methods

We can also define generic methods. Let's look at an example of a generic method that takes a slice of any type and returns the first element of the slice.

```go title="example.go"
package main

import "fmt"

type Slice[T any] []T

func (s Slice[T]) First() T {
    return s[0]
}

func main() {
    fmt.Println(Slice([]int{1, 2, 3}).First())
    fmt.Println(Slice([]string{"a", "b", "c"}).First())
}
```

In the above example, we defined a generic method `First` that takes a slice of any type `T` and returns the first element of the slice. We then called the method with two different types, `int` and `string`. The compiler is able to infer the type of the slice from the arguments passed to the method.

<Nugget>
  <p>
    A method is a function with a special receiver argument. The receiver
    appears in its own argument list between the <code>func</code> keyword and
    the method name. In the above example, the method <code>First</code> has a
    receiver of type <code>Slice[T]</code>. This means that the method can only
    be called on a variable of type <code>Slice[T]</code>.
  </p>
</Nugget>

## Generic Variadic Functions

We can also define generic variadic functions. Let's look at an example of a generic variadic function that takes a slice of any type and returns the first element of the slice.

```go title="example.go"

package main

import "fmt"

func First[T any](s ...T) T {
    return s[0]
}

func main() {
    fmt.Println(First(1, 2, 3))
    fmt.Println(First("a", "b", "c"))
}
```

<Nugget>
  <p>
    A variadic function is a function that takes a variable number of arguments.
    In Go, a variadic function is defined by adding an ellipsis (...) after the
    type of the last parameter. For example, the function <code>First</code> in
    the above example is a variadic function because it takes a variable number
    of arguments of type <code>T</code>.
  </p>
</Nugget>

In the example above, we defined a generic variadic function `First` that takes a slice of any type `T` and returns the first element of the slice. We then called the function with two different types, `int` and `string`.

## Generic Variadic Methods

We can also define generic variadic methods. Let's look at an example of a generic variadic method that takes a slice of any type and returns the first element of the slice.

```go title="example.go"
package main

import "fmt"

type Slice[T any] []T

func (s Slice[T]) First() T {
    return s[0]
}

func main() {
    fmt.Println((Slice[int]{1, 2, 3}.First()))
    fmt.Println((Slice[string]{"a", "b", "c"}.First()))
}
```

In the above example, we defined a generic variadic method `First` that takes a slice of any type `T` and returns the first element of the slice. We then called the method with two different types, `int` and `string`. The compiler is able to infer the type of the slice from the arguments passed to the method.

## Generic Variadic Types

We can also define generic variadic types. Let's look at an example of a generic variadic type that implements the `Writer` interface.

```go title="example.go"
package main

import (
    "fmt"
    "io"
    "os"
)

type Writer[T any] struct {
    w io.Writer
}

func (w *Writer[T]) Write(p []byte) (n int, err error) {
    return w.w.Write(p)
}

func main() {
    w := Writer[int]{w: os.Stdout}
    w.Write([]byte("Hello, world!\n"))
}
```

In the above example, we defined a generic variadic type `Writer` that implements the `Writer` interface. We then defined a variable `w` of type `Writer[int]` and assigned it to `os.Stdout`. This is possible because `os.Stdout` implements the `Writer` interface. We then called the `Write` method on the variable `w` and passed a slice of bytes to it.

## Generic Variadic Constraints

We can also add constraints to generic variadic types and functions. Let's look at an example of a generic variadic function that takes a slice of any type that implements the `io.Writer` interface and returns the first element of the slice.

```go title="example.go"

package main

import (
    "fmt"
    "io"
    "os"
)

func First[T io.Writer](s ...T) T {
    return s[0]
}

func main() {
    // assign the first writer to w
    w := First(os.Stdout, os.Stderr, )
    // print to w
    fmt.Fprintln(w, "Hello, world!")
}
```

Here function `First` takes a slice of any type `T` that implements the `io.Writer` interface and returns the first element of the slice. We then called the function with two different types, `os.Stdout` and `os.Stderr`. It worked as expected because both `os.Stdout` and `os.Stderr` implement the `io.Writer` interface.

## Conclusion

Golang is a statically typed language. This means that the type of a variable is known at compile time. In this article, we looked at how to define generic types, functions, methods, and variadic functions and methods in Golang. We also looked at how to add constraints to generic types, functions, methods, and variadic functions and methods.
