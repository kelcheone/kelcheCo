---
author: Kevin Kelche
title: How to convert byte array to string in Golang
description: In Go, you can convert a byte array to a string using the `string()` function. This function takes a byte array as an argument and returns a string. You can also use the `fmt.Sprintf()` function to convert a byte array to a string.
date: 18 January 2023
image: https://unsplash.com/photo-1671738423108-32c0ed3684bd?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1032&q=80
imageDescription:
imageSource: Unsplash
imageUrl: https://unsplash.com/photos/EmJy3_FV1ZI
keywords:
  -
tags:
  - golang
draft: true
---

description: "Learn about Golang closures: their syntax, scope, and lifetime of variables, creating higher-order functions, common use cases, and best practices."

A clousre is a function that references variables from outside its body, even when the function is called outside its original scope. This phenomenon can also be said as a closure **closes over** its environment and can access variables from its enclosing scope.

Before going into the details of closures, let's first understand the concept of scope and higher-order functions.

## Scope

In programming, scope refers to the visibility of variables, functions, and other objects. In Go, there are two types of scopes: **package scope** and **block scope**. A package scope is the default scope in Go and is the scope of a package in a way that variables are visible throughout the package. A block scope is the scope of a block of code such as a function or a loop. These variables are only visible within the block.

## Higher-Order Functions

Higher-order functions are functions that take other functions as arguments or return a function as a result. Since funcitons are first-class citizens in Go, they can be passed as arguments to other functions or returned as a result from other functions.

In higher-order funcitons anonymous functions are often used. <Link url="/blog/go/golang-anonymous-functions">Anonymous functions</Link> are funcitons that are not bound to an identifier.

```go title="main.go"
package main

import "fmt"

func myfunc(f func(int) int) {
    fmt.Println(f(5))
}

func someFunc() func() int {
    var sum int
    return func() int {
        sum++
        return sum
    }
}

func main() {
    myfunc(func(x int) int {
        return x * x
    })

    f := someFunc()
    for i := 0; i < 10; i++ {
      fmt.Println(f(i))
    }
}
```

In the above example, the function myfunc takes another function as an argument and calls it. The function myFunc2 returns a function that adds the argument to a variable sum and returns the sum. These are examples of higher-order functions.

Let's embark on the journey of closures.

## Closures

Let's take a look at the example below:

```go title="main.go"
package main

import "fmt"

func someFunc() func() int {
    var sum int
    return func() int {
        sum++
        return sum
    }
}

func main() {
    f := someFunc()
    fmt.Println(f())
    fmt.Println(f())
    fmt.Println(f())
}
```

The function someFunc returns a function that adds the argument to a variable sum that is declared in the enclosing scope and returns the sum. The function someFunc is called and the returned function is assigned to the variable f. The variable f is then called three times. The output of the program is:

```bash title="output"
1
2
3
```

From the output
