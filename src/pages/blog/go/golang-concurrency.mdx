---
layout: "@layouts/ArticleLayout.astro"
author: Kevin Kelche
title: Concurrency in Go and Goroutines
description: Example description
date: 25 January 2023
image: /images/golang-concurrency.svg
imageDescription:
keywords:
  -
tags:
  - golang

draft: true
---

import SectionLink from "@components/SectionLink.jsx";
import Nugget from "@components/Nugget.astro";
import Link from "@components/Link.jsx";
import Table from "@components/Table.jsx";

## Introduction

### What is concurrency?

Concurrency can be described as **the composition of independently executing processes or tasks**. In other words, concurrency is the ability to run multiple tasks at the same time. For instance, if you are watching a movie and you are also texting a friend, you are doing two things at the same time. You are doing things at the same time but not simultaneously.

Concurrency is different from parallelism. **Parallelism is the ability to run multiple tasks simultaneously**.
For instance, a person can dance and sing at the same time. This is parallelism because the person is doing two things simultaneously.

<Nugget>
  Even though Golang is a concurrent programming language, it does not mean that
  you can't write parallel programs in Golang.
</Nugget>

### Concurrency in Golang

Golang is termed as a concurrent programming language. The reason for this is that Golang has a built-in concurrency model. Golang achives concurrency by using goroutines and channels.

## Goroutines

Goroutines are lightweight threads, they are multiplexed onto multiple kernel threads and are managed by the Go runtime. The Go runtime is responsible for scheduling goroutines onto kernel threads.

Goroutines are termed as lightweight since the overhead of creating a goroutine is very small and cheap unlike spinnig up another thread in the kernel space.

You can learn more the Golang runtime scheduler <Link url="/blog/go/golang-scheduling">here</Link>.

### How to create a goroutine

Golang provides an easy API to create a goroutine. The keyword `go` is used to create a goroutine. The `go` keyword is placed in front of the function call. For example, the following code creates a goroutine that prints "Hello World" every second.

```go title="main.go"
package main

import (
  "fmt"
  "time"
)

func main() {
  go func() {
    for {
      fmt.Println("Hello World")
      time.Sleep(time.Second)
    }
  }()

  time.Sleep(time.Second * 5)
}
```

The `main` function has to sleep for 5 seconds so that the goroutine has time to execute. If the `main` function exits before the goroutine executes, the goroutine will be terminated.

Goroutines are executed in the same address space meaning that access to the shared memory needs to boe synchronized. This is done using `channels` or the `sync` package.

### Goroutine lifecycle

Goroutines are created and destroyed by the Go runtime. The Go runtime is responsible for scheduling goroutines onto kernel threads. The Go runtime is also responsible for garbage collecting goroutines.

### Goroutine scheduling

The Go runtime uses a preemptive scheduling algorithm. This means that the Go runtime can preempt a goroutine at any time. The Go runtime uses a timer to preempt a goroutine. The timer is set to the time when the goroutine should be preempted. When the timer expires, the Go runtime preempts the goroutine and schedules another goroutine to run.

### Goroutine stack size

The default stack size is 2KB. This can be changed by setting the `GOGCFLAGS` environment variable. For example, the following command sets the stack size to 4KB.

```bash
GOGCFLAGS="-stack_size=4" go run main.go
```

## Channels

In this section we explore channels in brief detail. You can learn more about channels <Link url="/blog/go/golang-channels">here</Link>.

Channels are a way for goroutines to communicate with each other. They behave pipes that connect goroutines together. You can send and receive values on channels. The values sent and received on channels are typed. Channels are created using the `make` function.

{/* IDk */}

### Concurrency

Concurrency is the ability of a program to run multiple tasks at the same time. Concurrency is important for programs that need to do multiple things at once, such as a web server that needs to handle multiple requests at the same time. Concurrency is different from parallelism, which is the ability of a program to run multiple tasks at the same time on multiple processors. Go is a concurrent language, but not a parallel language. Go programs can run on multiple processors, but they don't necessarily run in parallel.

### Goroutines

Goroutines enable concurrency in Go. Goroutines can be defined as a lightweight thread of execution. Goroutines are multiplexed onto multiple OS threads. Goroutines are created and managed by the Go runtime.

### Goroutine Scheduling

Goroutines are scheduled by the Go runtime. The Go runtime uses a cooperative scheduling model. This means that goroutines are scheduled by the runtime only when they yield the processor. Goroutines yield the processor when they block on a channel operation, when they call a blocking system call, or when they call the runtime.Gosched() function. The Gosched() function yields the processor to allow other goroutines to run. The Gosched() function is rarely used in practice.

### How Goroutines Work

When a Go program starts, it creates a single goroutine, called the main goroutine. The main goroutine is responsible for calling the main function. All other goroutines are created by the main goroutine. When the main function returns, the program exits, even if other goroutines are still running.

Goroutines are scheduled by the Go runtime. The Go runtime uses a scheduler to schedule goroutines onto OS threads. The Go runtime uses a cooperative scheduling model, which means that goroutines voluntarily give up their time on the OS thread. The Go runtime uses a M:N scheduling model, which means that M goroutines are scheduled onto N OS threads.

Another important thing to note is that goroutines are not preemptively scheduled. This means that goroutines are not scheduled based on priority. Goroutines are scheduled based on availability. This is important because it means that goroutines can be starved if they are not scheduled often enough.
